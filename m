Return-path: <linux-media-owner@vger.kernel.org>
Received: from mail.kapsi.fi ([217.30.184.167]:32910 "EHLO mail.kapsi.fi"
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752860Ab3KNXsY (ORCPT <rfc822;linux-media@vger.kernel.org>);
	Thu, 14 Nov 2013 18:48:24 -0500
Message-ID: <52856141.5010502@iki.fi>
Date: Fri, 15 Nov 2013 01:48:17 +0200
From: Antti Palosaari <crope@iki.fi>
MIME-Version: 1.0
To: David Howells <dhowells@redhat.com>,
	Mauro Carvalho Chehab <mchehab@infradead.org>
CC: linux-media@vger.kernel.org,
	Jarkko Korpi <jarkko_korpi@hotmail.com>
Subject: Re: I2C transfer logs for Antti's DS3103 driver and DVBSky's DS3103
 driver
References: <20271.1384472102@warthog.procyon.org.uk>
In-Reply-To: <20271.1384472102@warthog.procyon.org.uk>
Content-Type: multipart/mixed;
 boundary="------------020303040200030803060304"
Sender: linux-media-owner@vger.kernel.org
List-ID: <linux-media.vger.kernel.org>

This is a multi-part message in MIME format.
--------------020303040200030803060304
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Hello
You have to identify situation where it does not work, optimally single 
known channel. Then switch to working driver and tune that same channel 
and take sniffs. Then generate code from sniffs, copy paste that to 
non-working driver until it starts working. Then it is quite trivial to 
find out by error and trial tests & binary search where the problematic 
register is.

Here is some tips.
http://blog.palosaari.fi/2013/07/generating-rtl2832u-driver-code.html

Hacking script I used is attached, just for the example.

regards
Antti



On 15.11.2013 01:35, David Howells wrote:
>
> Here are four logs from doing:
>
> 	scandvb -a1 ./e.1
>
> where the contents of file e.1 are:
>
> 	S 11919000 V 27500000 3/4
>
> which is probing a region on the Eutelsat-9A satellite broadcast.
>
> I inserted:
>
> 	diff -uNr linux-3.11.7-300.dvbsky_4.fc20.x86_64/drivers/i2c/i2c-core.c i2c-monitor/drivers/i2c/i2c-core.c
> 	--- i2c-monitor/drivers/i2c/i2c-core.c	2013-09-02 21:46:10.000000000 +0100
> 	+++ linux-3.11.7-300.dvbsky_4.fc20.x86_64/drivers/i2c/i2c-core.c	2013-11-14 22:11:08.757282401 +0000
> 	@@ -1491,6 +1491,16 @@
> 		unsigned long orig_jiffies;
> 		int ret, try;
>
> 	+	for (ret = 0; ret < num; ret++) {
> 	+		if (msgs[ret].flags & I2C_M_RD)
> 	+			pr_notice("I2C %s: RD %02x %u\n",
> 	+				  adap->name, msgs[ret].addr, msgs[ret].len);
> 	+		else
> 	+			pr_notice("I2C %s: WR %02x %u [%*phN]\n",
> 	+				  adap->name, msgs[ret].addr, msgs[ret].len,
> 	+				  msgs[ret].len, msgs[ret].buf);
> 	+	}
> 	+
> 		/* Retry automatically on arbitration loss */
> 		orig_jiffies = jiffies;
> 		for (ret = 0, try = 0; try <= adap->retries; try++) {
>
> into the kernel to generate these logs.
>
> The four logs are:
>
>   (1) DVBSky's megapatch: I2C traffic generated by cx23885 module initialisation
>       and probing.
>
>   (2) DVBSky's megapatch: I2C traffic generated by the aforementioned scandvb
>       command.
>
>   (3) Antti's drivers plus my S952 glue: I2C traffic generated by cx23885
>       module initialisation and probing.
>
>   (4) Antti's drivers plus my S952 glue: I2C traffic generated by the
>       aforementioned scandvb command.
>
> The scandvb command with the DVBSky megapatch gave:
>
> 	dumping lists (25 services)
> 	Italy Service:11919:v:0:27500:2003:3003:3
> 	Karusel int:11919:v:0:27500:2004:3004:4
> 	SVT WORLD:11919:v:0:27500:2008:3008:8
> 	...
>
> and was very consistent.
>
> Antti's patch gave:
>
> 	dumping lists (22 services)
> 	[0001]:11919:v:0:27500:0:0:1
> 	[0003]:11919:v:0:27500:0:0:3
> 	[000d]:11919:v:0:27500:0:0:13
> 	...
>
> and sometimes:
>
> 	dumping lists (0 services)
>
> and once:
>
> 	dumping lists (32 services)
> 	[f714]:11919:v:0:27500:0:0:63252
> 	[e38b]:11919:v:0:27500:0:0:58251
> 	[b7ba]:11919:v:0:27500:0:0:47034
> 	...
>
> David
>


-- 
http://palosaari.fi/

--------------020303040200030803060304
Content-Type: text/x-python;
 name="em28xx_m88ds3103.py"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="em28xx_m88ds3103.py"

#!/usr/bin/env python
# Copyright (C) 2013 Antti Palosaari <crope@iki.fi>
# Usage: 

import os
import sys
import re
import struct
import string

fread = file(sys.argv[1], 'r' )

def get_hex_string(ele, start, length):
    string = '"'
    for i in range(length):
        string = string + '\\x' + ele[start + i]
    string = string + '"'
    return string

for line in fread:
    line = line.strip();
    ele = re.split(' ', line)

    print '// ' + line

#025099:  OUT: 000000 ms 009725 ms 40 02 00 00 c0 00 02 00 >>>  00 03
#025522:  OUT: 000000 ms 024417 ms 40 02 00 00 d0 00 02 00 >>>  03 11

    if (len(ele) > 17 and ele[15] == '>>>' and ele[8] == '02'):
        length = int(ele[13], 16) - 1
        if (ele[11] == 'c0'):
            print 'ret = m88ts2022_wr_regs(priv, 0x' + ele[17] + ', ' + \
            get_hex_string(ele, 18, length) + ', ' + str(length) + '); // generated'
        elif (ele[11] == 'd0'):
            print 'ret = m88ds3103_wr_regs(priv, 0x' + ele[17] + ', ' + \
            get_hex_string(ele, 18, length) + ', ' + str(length) + '); // generated'

fread.close()


--------------020303040200030803060304--
